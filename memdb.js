// Generated by CoffeeScript 1.9.0
(function() {
  var AbstractIterator, AbstractNoSQL, Errors, MemDB, MemIterator, NotFoundError, createRBT, globalStore, gt, gte, inherits, lt, lte, ltgt, setImmediate, toKey;

  createRBT = require('functional-red-black-tree');

  inherits = require('inherits-ex');

  AbstractNoSQL = require('abstract-nosql');

  AbstractIterator = require('abstract-iterator');

  Errors = require('abstract-error');

  NotFoundError = Errors.NotFoundError;

  ltgt = require('ltgt');

  setImmediate = global.setImmediate || process.nextTick;

  globalStore = {};

  toKey = function(key) {
    if (typeof key === 'string') {
      return '$' + key;
    } else {
      return JSON.stringify(key);
    }
  };

  gt = function(value) {
    return value > this._endValue;
  };

  gte = function(value) {
    return value >= this._endValue;
  };

  lt = function(value) {
    return value < this._endValue;
  };

  lte = function(value) {
    return value <= this._endValue;
  };

  MemIterator = (function() {
    inherits(MemIterator, AbstractIterator);

    function MemIterator(db, options) {
      var tree;
      MemIterator.__super__.constructor.call(this, db, options);
      options = this.options;
      this._limit = options.limit;
      if (this._limit === -1) {
        this._limit = Infinity;
      }
      tree = db._store[db._location];
      this.keyAsBuffer = options.keyAsBuffer === true;
      this.valueAsBuffer = options.valueAsBuffer === true;
      this._reverse = options.reverse;
      this._done = 0;
      if (!this._reverse) {
        this._incr = 'next';
        this._start = ltgt.lowerBound(options);
        this._endValue = ltgt.upperBound(options);
        if (typeof this._start === 'undefined') {
          this._tree = tree.begin;
          if (options.gt === null) {
            this._tree.next();
          }
        } else if (ltgt.lowerBoundInclusive(options)) {
          this._tree = tree.ge(this._start);
        } else {
          this._tree = tree.gt(this._start);
        }
        if (this._endValue) {
          if (ltgt.upperBoundInclusive(options)) {
            this._test = lte;
          } else {
            this._test = lt;
          }
        }
      } else {
        this._incr = 'prev';
        this._start = ltgt.upperBound(options);
        this._endValue = ltgt.lowerBound(options);
        if (typeof this._start === 'undefined') {
          this._tree = tree.end;
          if (options.lt === null) {
            this._tree.prev();
          }
        } else if (ltgt.upperBoundInclusive(options)) {
          this._tree = tree.le(this._start);
        } else {
          this._tree = tree.lt(this._start);
        }
        if (this._endValue) {
          if (ltgt.lowerBoundInclusive(options)) {
            this._test = gte;
          } else {
            this._test = gt;
          }
        }
      }
      return;
    }

    MemIterator.prototype._nextSync = function() {
      var key, value;
      if (this._done++ >= this._limit) {
        return false;
      }
      if (!this._tree.valid) {
        return false;
      }
      key = this._tree.key;
      value = this._tree.value;
      if (!this._test(key)) {
        return false;
      }
      if (this.keyAsBuffer) {
        key = new Buffer(key);
      }
      if (this.valueAsBuffer) {
        value = new Buffer(value);
      }
      this._tree[this._incr]();
      return [key, value];
    };

    MemIterator.prototype._test = function() {
      return true;
    };

    return MemIterator;

  })();

  module.exports = MemDB = (function() {
    inherits(MemDB, AbstractNoSQL);

    function MemDB(location) {
      if (!(this instanceof MemDB)) {
        return new MemDB(location);
      }
      MemDB.__super__.constructor.call(this, typeof location === 'string' ? location : '');
      this._location = this.location ? toKey(this.location) : '_tree';
      this._store = this.location ? globalStore : this;
      this._store[this._location] = this._store[this._location] || createRBT();
      return;
    }

    MemDB.prototype.finalize = function() {
      if (this._store !== this) {
        delete globalStore[this._location];
      }
    };

    MemDB.prototype._openSync = function() {
      return true;
    };

    MemDB.prototype._putSync = function(key, value, options) {
      this._store[this._location] = this._store[this._location].remove(key).insert(key, value);
      return true;
    };

    MemDB.prototype._isExistsSync = function(key, options) {
      var result;
      result = this._store[this._location].get(key);
      if (result === void 0) {
        result = false;
      } else {
        result = true;
      }
      return result;
    };

    MemDB.prototype._getSync = function(key, options) {
      var value;
      value = this._store[this._location].get(key);
      if (value === void 0) {
        throw new NotFoundError;
      }
      if (options.asBuffer === true && !this._isBuffer(value)) {
        value = new Buffer(String(value));
      }
      return value;
    };

    MemDB.prototype._delSync = function(key, options) {
      this._store[this._location] = this._store[this._location].remove(key);
      return true;
    };

    MemDB.prototype._batchSync = function(array, options) {
      var err, i, key, len, tree, value;
      i = -1;
      len = array.length;
      tree = this._store[this._location];
      while (++i < len) {
        if (!array[i]) {
          continue;
        }
        key = this._isBuffer(array[i].key) ? array[i].key : String(array[i].key);
        err = this._checkKey(key, 'key');
        if (err) {
          throw err;
        }
        tree = tree.remove(array[i].key);
        if (array[i].type === 'put') {
          value = this._isBuffer(array[i].value) ? array[i].value : String(array[i].value);
          err = this._checkKey(value, 'value');
          if (err) {
            throw err;
          }
          tree = tree.insert(key, value);
        }
      }
      this._store[this._location] = tree;
      return true;
    };

    MemDB.prototype.IteratorClass = MemIterator;

    MemDB.prototype._isBuffer = function(obj) {
      return Buffer.isBuffer(obj);
    };

    MemDB.destroy = function(name, callback) {
      var key;
      key = toKey(name);
      if (key in globalStore) {
        delete globalStore[key];
      }
      setImmediate(callback);
    };

    return MemDB;

  })();

}).call(this);
